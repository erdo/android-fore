/**
 *
 * ./gradlew check
 *
 * ./gradlew testDebugUnitTest --info
 * ./gradlew connectedAndroidTest -PtestBuildType=debug
 * ./gradlew connectedAndroidTest -PtestBuildType=release
 *
 * ./gradlew example-kt-01reactiveui:testDebugUnitTest --info
 *
 * ./gradlew clean
 * ./gradlew publishToMavenLocal
 * ./gradlew bintrayUpload
 *
 */
apply plugin: 'maven-publish'
apply plugin: 'com.jfrog.bintray'

println "[${LIB_ARTIFACT_ID} publish file]"

group = "${rootProject.ext.LIB_GROUP}"
version =  "${rootProject.ext.LIB_VERSION_NAME}"

// https://antoniocappiello.com/2015/11/11/publish-your-library-to-jcenter-in-3-steps/

// https://github.com/bintray/gradle-bintray-plugin
bintray {

	user = "${rootProject.ext.BINTRAY_USER}"
	key = "${rootProject.ext.BINTRAY_API_KEY}"

	publications = ['Production']

	pkg {
		repo = REPO
		name = LIB_ARTIFACT_ID
		desc = LIB_DESCRIPTION
		websiteUrl = POM_URL
		vcsUrl = POM_SCM_CONNECTION
		licenses = [LICENCE_SHORT_NAME]
		publish = true
		publicDownloadNumbers = false
	}

}

task androidSourcesJar(type: Jar) {
	classifier = 'sources'
	from android.sourceSets.main.java.srcDirs
}

project.afterEvaluate {
	publishing {
		publications {
			Production(MavenPublication) {
				groupId rootProject.ext.LIB_GROUP
				artifactId LIB_ARTIFACT_ID
				version = rootProject.ext.LIB_VERSION_NAME

				artifact bundleReleaseAar
				artifact androidSourcesJar

				pom.withXml {

					asNode().appendNode('name', rootProject.ext.PROJ_NAME)
					asNode().appendNode('description', LIB_DESCRIPTION)
					asNode().appendNode('url', rootProject.ext.POM_URL)

					final licenceNode = asNode().appendNode('licenses').appendNode('license')
					licenceNode.appendNode('name', rootProject.ext.LICENCE_NAME)
					licenceNode.appendNode('url', rootProject.ext.LICENCE_URL)

					final developerNode = asNode().appendNode('developers').appendNode('developer')
					developerNode.appendNode('id', rootProject.ext.LIB_DEVELOPER_ID)
					developerNode.appendNode('name', rootProject.ext.LIB_DEVELOPER_NAME)
					developerNode.appendNode('email', rootProject.ext.LIB_DEVELOPER_EMAIL)

					final scmNode = asNode().appendNode('scm')
					scmNode.appendNode('connection', rootProject.ext.POM_SCM_CONNECTION)
					scmNode.appendNode('developerConnection', rootProject.ext.POM_SCM_CONNECTION)
					scmNode.appendNode('url', rootProject.ext.POM_SCM_URL)

					// https://gist.github.com/gsavvid/f7ffe00d846a50de7490c2ecbd7b4169

					def dependenciesNode = asNode().appendNode('dependencies')

					// List all compile dependencies and write to POM
					ext.addDependency = { dep, String scope ->
						if (dep.group == null || dep.version == null || dep.name == null || dep.name == "unspecified")
							return // ignore invalid dependencies

						final dependencyNode = dependenciesNode.appendNode('dependency')
						dependencyNode.appendNode('groupId', dep.group)
						dependencyNode.appendNode('artifactId', dep.name)
						dependencyNode.appendNode('version', dep.version)
						dependencyNode.appendNode('scope', scope)

						if (!dep.transitive) {
							// If this dependency is not transitive, we should force exclude all its dependencies from the POM
							final exclusionNode = dependencyNode.appendNode('exclusions').appendNode('exclusion')
							exclusionNode.appendNode('groupId', '*')
							exclusionNode.appendNode('artifactId', '*')
						} else if (!dep.properties.excludeRules.empty) {
							// Otherwise add specified exclude rules
							final exclusionsNode = dependencyNode.appendNode('exclusions')
							dep.properties.excludeRules.each { rule ->
								final exclusionNode = exclusionsNode.appendNode('exclusion')
								exclusionNode.appendNode('groupId', rule.group ?: '*')
								exclusionNode.appendNode('artifactId', rule.module ?: '*')
							}
						}
					}

					// List all "compile" dependencies (for old Gradle)
					configurations.compile.getDependencies().each { dep -> addDependency(dep, "compile") }
					// List all "api" dependencies (for new Gradle) as "compile" dependencies
					configurations.api.getDependencies().each { dep -> addDependency(dep, "compile") }
					// List all "implementation" dependencies (for new Gradle) as "runtime" dependencies
					configurations.implementation.getDependencies().each { dep -> addDependency(dep, "runtime") }
				}
			}
		}
	}
}
